from typing import List

"""
给定一个未排序的整数数组，找出其中没有出现的最小的正整数。

示例 1:

输入: [1,2,0]
输出: 3
示例 2:

输入: [3,4,-1,1]
输出: 2
示例 3:

输入: [7,8,9,11,12]
输出: 1
说明:

你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/first-missing-positive
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
"""


class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        c = [0] * ((len(nums) // (4 * 8)) + 1)
        m = len(nums)
        for i in nums:
            if i > m or i < 1:
                continue
            else:
                ci = i // (4 * 8)
                di = i % (4 * 8)
                c[ci] = 1 << di | c[ci]
        for ci, cv in enumerate(c):
            if cv != b'1111111111111111':
                for i in range(0, 32):
                    if (1 << i & cv) == 0:
                        if i + (ci * 4 * 8) != 0:
                            return (i + (ci * 4 * 8))
            else:
                continue
        return len(c) * 4 * 8


if __name__ == '__main__':
    l = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
         31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58,
         59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86,
         87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
         112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127]
    print(Solution().firstMissingPositive(l))
